# Debian自动配置脚本

## 一、运行

- 复制脚本内容保存为auto-script.sh

```bash
#!/bin/bash

# 检查root权限
if [ "$EUID" -ne 0 ]; then
    echo "❌ 请使用 root 或 sudo 权限执行此脚本！"
    exit 1
fi

# 主菜单
function main_menu() {
    clear
    echo "🚀 Debian 12 自动配置脚本"
    echo "============================"
    echo " 1. 配置静态IP"
    echo " 2. 恢复DHCP"
    echo " 3. 换中科大源"
    echo " 4. 安装UFW防火墙"
    echo " 5. 配置UFW防火墙规则"
    echo " 6. 安装Docker及Docker Compose"
    echo " 7. SSH免密登录设置"
    echo " 8. 系统垃圾清理（每月自动）"
    echo " 9. 系统性能和存储优化"
    echo "10. 时间同步和设置时区"
    echo "11. 禁用IPv6"
    echo "12. 修改主机名"
    echo "13. 安装qemu-guest-agent"
    echo "14. 安装并配置OpenSSH"
    echo "15. 监控系统运行状态"
    echo " 0. 退出脚本"
    echo "============================"
    read -p "请选择一个操作 [0-15]: " choice
    case $choice in
        1) configure_static_ip ;;
        2) restore_dhcp ;;
        3) switch_ustc_source ;;
        4) install_ufw ;;
        5) configure_ufw ;;
        6) install_docker ;;
        7) setup_ssh_nopass ;;
        8) setup_cleanup ;;
        9) performance_optimize ;;
        10) setup_time_sync ;;
        11) disable_ipv6 ;;
        12) change_hostname ;;
        13) install_qemu_agent ;;
        14) install_openssh ;;
        15) monitor_system ;;
        0) exit 0 ;;
        *) echo "无效选择，请重新输入！" && sleep 2 && main_menu ;;
    esac
}

# 请将以下所有你附件中的功能脚本依次完整复制到对应函数中：

function configure_static_ip(){
    # 2.1 配置静态IP
    #!/bin/bash
    
    # Debian 12 静态IP配置脚本，直接编辑 /etc/network/interfaces，并手动更新 /etc/resolv.conf DNS设置
    
    INTERFACES_FILE="/etc/network/interfaces"
    RESOLV_FILE="/etc/resolv.conf"
    
    # 备份当前配置
    cp ${INTERFACES_FILE} ${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
    cp ${RESOLV_FILE} ${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
    echo "已备份网络配置文件：${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
    echo "已备份DNS配置文件：${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
    
    # 输入网卡名称
    read -p "请输入网卡名（如eth0或ens18，默认ens18）: " INTERFACE
    INTERFACE=${INTERFACE:-ens18}
    
    # 获取系统当前IP、掩码、网关、DNS作为默认值
    CURRENT_IP=$(ip -4 addr show ${INTERFACE} | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
    CURRENT_NETMASK=$(ifconfig ${INTERFACE} | grep -oP '(?<=netmask\s)\d+(\.\d+){3}')
    CURRENT_GATEWAY=$(ip route | grep default | grep ${INTERFACE} | awk '{print $3}')
    CURRENT_DNS=$(grep "nameserver" /etc/resolv.conf | head -n1 | awk '{print $2}')
    
    # 设置默认值（如果获取不到则使用常规默认值）
    [ -z "$CURRENT_NETMASK" ] && CURRENT_NETMASK="255.255.255.0"
    [ -z "$CURRENT_GATEWAY" ] && CURRENT_GATEWAY="192.168.1.1"
    [ -z "$CURRENT_DNS" ] && CURRENT_DNS="8.8.8.8"
    
    # 用户输入新配置，提供默认值
    read -p "请输入静态IP地址（默认：${CURRENT_IP}）: " STATIC_IP
    STATIC_IP=${STATIC_IP:-$CURRENT_IP}
    
    read -p "请输入子网掩码（默认：${CURRENT_NETMASK}）: " NETMASK
    NETMASK=${NETMASK:-$CURRENT_NETMASK}
    
    read -p "请输入网关地址（默认：${CURRENT_GATEWAY}）: " GATEWAY
    GATEWAY=${GATEWAY:-$CURRENT_GATEWAY}
    
    read -p "请输入DNS服务器（默认：${CURRENT_DNS}，多个DNS空格分隔）: " DNS
    DNS=${DNS:-$CURRENT_DNS}
    
    # 删除 interfaces 文件中已有的该网卡配置（若存在）
    sed -i "/iface ${INTERFACE} inet/,/^$/d" ${INTERFACES_FILE}
    sed -i "/auto ${INTERFACE}/d" ${INTERFACES_FILE}
    sed -i "/allow-hotplug ${INTERFACE}/d" ${INTERFACES_FILE}
    
    # 写入新的静态IP配置到interfaces文件
cat >> ${INTERFACES_FILE} <<EOF

auto ${INTERFACE}
iface ${INTERFACE} inet static
    address ${STATIC_IP}
    netmask ${NETMASK}
    gateway ${GATEWAY}
EOF
    
    echo "静态IP地址已成功配置到${INTERFACES_FILE}"
    
    # 写入DNS配置到resolv.conf文件
    echo "# Generated by setup_static_ip.sh on $(date)" > ${RESOLV_FILE}
    for dns_server in ${DNS}
    do
        echo "nameserver ${dns_server}" >> ${RESOLV_FILE}
    done
    
    echo "DNS已成功配置到${RESOLV_FILE}"
    
    # 重启网络服务以应用配置
    systemctl restart networking
    
    # 显示当前网络配置与DNS配置
    echo "当前${INTERFACE}接口网络信息为："
    ip addr show ${INTERFACE}
    echo ""
    echo "当前DNS配置信息为："
    cat ${RESOLV_FILE}
}

function restore_dhcp(){
    # 2.2 恢复DHCP
    #!/bin/bash
    
    # Debian 12 恢复 DHCP 配置脚本
    # 直接编辑 /etc/network/interfaces 文件并恢复DNS为DHCP自动获取
    
    INTERFACES_FILE="/etc/network/interfaces"
    RESOLV_FILE="/etc/resolv.conf"
    
    # 备份当前配置
    cp ${INTERFACES_FILE} ${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
    cp ${RESOLV_FILE} ${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
    echo "已备份网络配置文件：${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
    echo "已备份DNS配置文件：${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
    
    # 输入网卡名称
    read -p "请输入要恢复 DHCP 的网卡名（默认 ens18）: " INTERFACE
    INTERFACE=${INTERFACE:-ens18}
    
    # 删除 interfaces 文件中已有的该网卡配置（若存在）
    sed -i "/iface ${INTERFACE} inet/,/^$/d" ${INTERFACES_FILE}
    sed -i "/auto ${INTERFACE}/d" ${INTERFACES_FILE}
    sed -i "/allow-hotplug ${INTERFACE}/d" ${INTERFACES_FILE}
    
    # 写入 DHCP 配置到 interfaces 文件
cat >> ${INTERFACES_FILE} <<EOF

allow-hotplug ${INTERFACE}
iface ${INTERFACE} inet dhcp
EOF
    
    echo "已成功恢复 DHCP 配置到 ${INTERFACES_FILE}"
    
    # 清空 resolv.conf 以便 DHCP 自动更新DNS
    echo "# Generated by restore_dhcp.sh on $(date)" > ${RESOLV_FILE}
    
    # 重启网络服务应用配置
    systemctl restart networking
    
    # 等待几秒钟让 DHCP 获取地址
    echo "请稍等几秒钟，让 DHCP 获取 IP 地址..."
    sleep 5
    
    # 显示当前网络配置和DNS配置
    echo "当前 ${INTERFACE} 接口网络信息为："
    ip addr show ${INTERFACE}
    echo ""
    echo "当前 DNS 配置信息为："
    cat ${RESOLV_FILE}
}

function switch_ustc_source(){
    # 2.3 换中科大源
    #!/bin/bash
    
    # Debian 12 一键换源脚本（中国科学技术大学源）
    SOURCES_FILE="/etc/apt/sources.list"
    
    # 备份原sources.list文件
    cp ${SOURCES_FILE} ${SOURCES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
    echo "已备份原文件为 ${SOURCES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
    
    # 清空原文件内容，并写入新源内容
cat > ${SOURCES_FILE} <<EOF
# 默认注释了源码仓库，如有需要可自行取消注释
deb http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware
# deb-src http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware
deb http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware
# deb-src http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware

# backports 软件源，请按需启用
# deb http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware
# deb-src http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware
EOF
    
    echo "已成功替换软件源为中国科学技术大学镜像源。"
    
    # 更新软件源
    apt update
}

function install_ufw(){
    # 2.4 安装UFW
    #!/bin/bash
    
    # Debian 12 检查并安装UFW防火墙脚本
    
    # 检查是否已安装UFW
    if dpkg -s ufw &> /dev/null; then
        echo "✅ UFW 已经安装，无需再次安装。"
    else
        echo "⚙️ UFW 未安装，正在安装中..."
        apt update
        apt install -y ufw
        
        # 再次检查是否成功安装
        if dpkg -s ufw &> /dev/null; then
            echo "✅ UFW 安装成功！"
        else
            echo "❌ UFW 安装失败，请检查网络或软件源设置！"
            exit 1
        fi
    fi
    
    # 显示UFW当前状态
    echo ""
    echo "🔍 当前UFW状态："
    ufw status verbose
}

function configure_ufw(){
    # 2.5 UFW配置防火墙
    #!/bin/bash
    
    # Debian 12 UFW 防火墙配置脚本（用户自定义允许或禁用端口）
    
    # 检查UFW是否已安装
    if ! dpkg -s ufw &> /dev/null; then
        echo "⚠️ UFW 尚未安装，请先执行安装脚本再进行此操作。"
        exit 1
    fi
    
    echo "🚀 开始配置UFW防火墙..."
    
    # 设置默认规则
    echo "⚙️ 设置默认规则：默认拒绝入站流量，允许出站流量..."
    ufw default deny incoming
    ufw default allow outgoing
    
    # 显示当前ufw状态
    echo ""
    echo "📋 当前UFW规则如下:"
    ufw status numbered
    echo ""
    
    # 允许用户新增端口
    read -p "🛡️ 是否需要允许新的端口？(y/n): " open_ports
    if [[ "$open_ports" =~ ^[Yy]$ ]]; then
        read -p "请输入你想允许的端口号(如22 80 443)，多个端口以空格分隔: " ports_allow
        for port in $ports_allow; do
            ufw allow $port && echo "✅ 已允许端口 $port"
        done
    fi
    
    # 允许用户禁用之前开放的端口
    read -p "🚫 是否需要禁用之前开放的端口？(y/n): " close_ports
    if [[ "$close_ports" =~ ^[Yy]$ ]]; then
        read -p "请输入你想禁用的端口号(如22 80 443)，多个端口以空格分隔: " ports_deny
        for port in $ports_deny; do
            ufw delete allow $port && echo "✅ 已禁用端口 $port" || echo "⚠️ 禁用端口 $port 时出错或不存在该规则"
        done
    fi
    
    # 启用ufw（如果未启用）
    echo ""
    echo "🟢 启用UFW防火墙..."
    ufw --force enable
    
    # 重载规则
    ufw reload
    
    # 显示当前防火墙状态
    echo ""
    echo "📋 最终UFW防火墙状态:"
    ufw status verbose
}

function install_docker(){
    # 2.6 安装docker和docker compose
    apt update
    apt install ca-certificates curl
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
    chmod a+r /etc/apt/keyrings/docker.asc
    
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.aliyun.com/docker-ce/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" |tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    apt update
    apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
    
    systemctl start docker
    systemctl enable docker
    
    docker --version
    docker compose version
}

function setup_ssh_nopass(){
    # 2.7 SSH免密登录设置
    #!/bin/bash
    
    # SSH免密登录配置脚本（客户端Windows）
    
    echo "🚀 本脚本帮助你设置SSH公钥登录（免密码登录）"
    echo ""
    
    # 提示用户在本地生成密钥对
    echo "🔑 请在你的 Windows 10 客户端执行下面命令生成密钥对（如未生成）："
    echo ""
    echo "    ssh-keygen -t rsa -b 4096"
    echo ""
    echo "⚠️ 命令执行后一路回车即可，密钥默认保存在 C:\\Users\\你的用户名\\.ssh\\"
    echo ""
    
    # 提示用户打开公钥文件并复制内容
    echo "📋 请在 Windows 上打开公钥文件（默认路径）："
    echo ""
    echo "    C:\\Users\\你的用户名\\.ssh\\id_rsa.pub"
    echo ""
    echo "然后复制里面所有内容，接下来将在服务器端粘贴。"
    echo ""
    
    # 等待用户确认
    read -p "✅ 已复制公钥内容到剪贴板了吗？（y/n）：" is_copied
    
    if [[ "$is_copied" =~ ^[Yy]$ ]]; then
        # 创建.ssh目录并设置权限
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # 用户粘贴公钥到authorized_keys
        echo ""
        echo "✏️ 请将刚才复制的SSH公钥内容粘贴到下方："
        read -r ssh_pubkey
        
        # 检查是否为空
        if [[ -z "$ssh_pubkey" ]]; then
            echo "⚠️ 错误：未检测到公钥内容，退出配置。"
            exit 1
        fi
        
        # 将公钥写入authorized_keys文件
        echo "$ssh_pubkey" >> ~/.ssh/authorized_keys
        chmod 600 ~/.ssh/authorized_keys
        
        echo ""
        echo "✅ 公钥添加成功！"
    else
        echo "⚠️ 请先完成公钥复制操作，再重新运行本脚本。"
        exit 1
    fi
    
    # 提示用户测试免密登陆
    server_ip=$(hostname -I | awk '{print $1}')
    current_user=$(whoami)
    
    echo ""
    echo "🚩 现在请在 Windows 客户端上测试SSH免密登陆，命令如下："
    echo ""
    echo "    ssh ${current_user}@${server_ip}"
    echo ""
    
    echo "如果一切顺利，你无需输入密码即可成功登陆！🚀"
}

function setup_cleanup(){
    # 2.8 系统垃圾清理
    #!/bin/bash
    
    # 自动创建 Debian 垃圾清理脚本并配置每月末自动执行的任务
    
    CLEANUP_SCRIPT="/usr/local/bin/system_cleanup.sh"
    LOG_FILE="/var/log/system_cleanup.log"
    
    echo "🚩开始创建系统垃圾清理脚本..."
    
    # 创建自动清理脚本
cat > ${CLEANUP_SCRIPT} <<'EOF'
#!/bin/bash

# Debian 系统垃圾自动清理脚本

# 清理APT缓存
apt clean
apt autoclean
apt autoremove -y

# 删除临时文件
rm -rf /tmp/* /var/tmp/*

# 删除旧的压缩日志
find /var/log -type f -name "*.gz" -exec rm -f {} \;
find /var/log -type f -name "*.1" -exec rm -f {} \;

# 清空其他日志文件
find /var/log -type f -exec truncate -s 0 {} \;

# 删除用户的缩略图缓存（如果有图形界面）
rm -rf /home/*/.cache/thumbnails/*

# 输出执行时间到日志
echo "系统垃圾清理完成于 $(date)" >> /var/log/system_cleanup.log
EOF
    
    # 给脚本赋予执行权限
    chmod +x ${CLEANUP_SCRIPT}
    
    echo "✅ 垃圾清理脚本创建成功，路径为：${CLEANUP_SCRIPT}"
    
    # 配置定时任务（每月月底自动执行）
    echo "🚩 正在配置定时任务..."
    
    (crontab -l 2>/dev/null | grep -v "${CLEANUP_SCRIPT}"; \
    echo '59 23 28-31 * * [ "$(date -d tomorrow '\''+\%d'\'')" = "01" ] && /usr/local/bin/system_cleanup.sh') | crontab -
    
    echo "✅ 定时任务配置完成！"
    
    # 检查任务是否添加成功
    echo ""
    echo "🚩 正在检查定时任务是否添加成功..."
    
    if crontab -l | grep -q "${CLEANUP_SCRIPT}"; then
        echo "✅ 定时任务添加成功！当前定时任务列表如下："
        crontab -l | grep "${CLEANUP_SCRIPT}"
    else
        echo "❌ 定时任务添加失败，请检查后重试！"
        exit 1
    fi
    
    echo ""
    echo "🎉全部配置完成！系统每月最后一天23:59将自动清理垃圾文件。"
    echo "清理日志在：${LOG_FILE}"
}

function performance_optimize(){
    # 2.9 系统性能和存储优化
    #!/bin/bash
    
    echo "🚀 开始 Debian 12 (PVE 虚拟机) 性能优化..."
    
    # 1️⃣ 优化 swappiness 参数为10，降低swap使用频率
    echo "✅ 正在设置 swappiness 参数为10..."
    if grep -q "vm.swappiness" /etc/sysctl.conf; then
        sed -i 's/^vm.swappiness.*/vm.swappiness = 10/' /etc/sysctl.conf
    else
        echo "vm.swappiness = 10" >> /etc/sysctl.conf
    fi
    sysctl -p
    
    # 2️⃣ 启用 TCP BBR 拥塞控制算法以提高网络性能（虚拟机适用）
    echo "✅ 正在启用 TCP BBR 拥塞控制算法..."
    if ! grep -q "net.core.default_qdisc" /etc/sysctl.conf; then
        echo "net.core.default_qdisc = fq" >> /etc/sysctl.conf
    fi
    if ! grep -q "net.ipv4.tcp_congestion_control" /etc/sysctl.conf; then
        echo "net.ipv4.tcp_congestion_control = bbr" >> /etc/sysctl.conf
    fi
    sysctl -p
    
    # 验证 TCP BBR 是否启用成功
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        echo "✅ TCP BBR 已成功启用！"
    else
        echo "❌ TCP BBR 启用失败，请检查内核版本是否支持！"
    fi
    
    # 3️⃣ 检测虚拟机磁盘是否支持 TRIM (discard)，再决定是否启用定期 TRIM
    echo "✅ 正在检测虚拟磁盘是否支持 TRIM (discard)..."
    
    DISCARD_SUPPORT=$(lsblk -D | awk 'NR>1 && $4=="0B" {print $1}' | wc -l)
    
    if [ "$DISCARD_SUPPORT" -ne 0 ]; then
        echo "⚠️ 检测到虚拟磁盘不支持 TRIM，跳过启用 fstrim 服务。"
    else
        echo "✅ 虚拟磁盘支持 TRIM，正在启用 fstrim 服务..."
        systemctl enable --now fstrim.timer
        
        # 验证 fstrim 服务状态
        if systemctl is-enabled fstrim.timer | grep -q "enabled"; then
            echo "✅ fstrim 定期 TRIM 服务已成功启用！"
        else
            echo "❌ fstrim 服务启用失败，请手动检查。"
        fi
    fi
    
    echo ""
    echo "🎉 Debian 12 (PVE 虚拟机) 性能优化配置完成！"
}

function setup_time_sync(){
    # 2.10 时间同步和设置时区
    #!/bin/bash
    
    echo "🌐 Debian 12 (PVE虚拟机) 时间同步与时区设置脚本【默认时区: Asia/Shanghai】"
    
    # 检查是否以root权限运行
    if [ "$EUID" -ne 0 ]; then
        echo "❌ 请以 root 或 sudo 权限运行此脚本！"
        exit 1
    fi
    
    # 第一步：安装和启用chrony服务进行时间同步
    echo "🚩 正在安装和启用chrony时间同步服务..."
    apt update
    apt install -y chrony
    
    # 启用并启动chrony服务
    systemctl enable --now chrony
    
    # 验证chrony服务是否启动成功
    if systemctl is-active chrony | grep -q "active"; then
        echo "✅ chrony服务已成功启动和启用！"
    else
        echo "❌ chrony服务启动失败，请手动检查！"
        exit 1
    fi
    
    # 强制进行一次时间同步
    chronyc -a makestep
    
    # 显示当前时间同步源状态
    echo ""
    echo "🕒 当前chrony时间同步源状态："
    chronyc sources -v
    echo ""
    
    # 第二步：交互式设置时区（默认Asia/Shanghai，按回车使用默认值）
    default_timezone="Asia/Shanghai"
    current_tz=$(timedatectl | grep "Time zone" | awk '{print $3}')
    echo "⏰ 当前系统时区为：$current_tz"
    echo ""
    
    echo "请输入你想设置的时区，例如：Asia/Shanghai"
    echo "可用的时区列表参考：https://en.wikipedia.org/wiki/List_of_tz_database_time_zones"
    read -p "请输入新的时区 (默认: ${default_timezone}): " new_timezone
    
    # 如果用户未输入，使用默认值
    if [ -z "$new_timezone" ]; then
        new_timezone="$default_timezone"
    fi
    
    # 检查用户输入的时区是否有效
    if [ ! -f "/usr/share/zoneinfo/$new_timezone" ]; then
        echo "❌ 时区 [$new_timezone] 不存在，请检查拼写后重新运行脚本！"
        exit 1
    fi
    
    # 设置新时区
    timedatectl set-timezone "$new_timezone"
    
    # 显示设置后的时区和时间
    echo ""
    echo "✅ 时区设置成功！当前时区为：$(timedatectl | grep "Time zone" | awk '{print $3}')"
    echo "🕒 当前系统时间为：$(date)"
}

function disable_ipv6(){
    # 2.11 禁用IPv6
    #!/bin/bash
    
    echo "🚩 开始禁用 Debian 12 系统 IPv6 功能..."
    
    # 检查是否以root权限运行
    if [ "$EUID" -ne 0 ]; then
        echo "❌ 请以 root 或 sudo 权限运行此脚本！"
        exit 1
    fi
    
    # 备份sysctl.conf文件
    sysctl_conf="/etc/sysctl.conf"
    backup_conf="/etc/sysctl.conf.bak_ipv6"
    if [ ! -f "$backup_conf" ]; then
        cp $sysctl_conf $backup_conf
        echo "✅ 已备份原始sysctl.conf至 $backup_conf"
    fi
    
    # 禁用IPv6的sysctl配置
    echo "✅ 正在配置禁用IPv6..."
cat <<EOF >> $sysctl_conf

# 禁用IPv6
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1
EOF
    
    # 立即应用配置
    sysctl -p
    
    # 禁用IPv6模块加载（可选，推荐）
    echo "✅ 正在配置禁止IPv6模块加载..."
    modprobe_conf="/etc/modprobe.d/disable_ipv6.conf"
    echo "options ipv6 disable=1" > $modprobe_conf
    
    # 更新initramfs使模块禁用生效
    update-initramfs -u
    
    # 验证IPv6是否禁用成功
    if sysctl net.ipv6.conf.all.disable_ipv6 | grep -q "1"; then
        echo "✅ IPv6已成功禁用！"
    else
        echo "❌ IPv6禁用失败，请手动检查！"
    fi
    
    echo ""
    echo "🎉 Debian 12 IPv6禁用配置完成！请重启系统以确保彻底生效（推荐）！"
}

function change_hostname(){
    # 2.12 修改主机名
    #!/bin/bash
    
    echo "🚩 Debian 12 主机名修改脚本"
    
    # 检查是否以root权限运行
    if [ "$EUID" -ne 0 ]; then
        echo "❌ 请以 root 或 sudo 权限运行此脚本！"
        exit 1
    fi
    
    # 显示当前主机名
    current_hostname=$(hostnamectl hostname)
    echo "🔖 当前主机名为：$current_hostname"
    echo ""
    
    # 提示用户输入新的主机名 (默认为当前主机名)
    read -p "请输入新的主机名 (默认: $current_hostname): " new_hostname
    
    # 如果用户没有输入，使用当前主机名
    if [ -z "$new_hostname" ]; then
        new_hostname=$current_hostname
    fi
    
    # 验证主机名合法性（仅允许字母、数字、短横线，长度1-63字符）
    if [[ ! $new_hostname =~ ^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}$ ]]; then
        echo "❌ 主机名 [$new_hostname] 不合法！仅允许字母、数字、短横线，且长度为1-63字符。"
        exit 1
    fi
    
    # 设置新主机名
    echo "✅ 正在设置新主机名为：$new_hostname"
    hostnamectl set-hostname "$new_hostname"
    
    # 修改/etc/hosts文件，确保主机名解析正确
    if grep -q "127.0.1.1" /etc/hosts; then
        sed -i "/127.0.1.1/c\127.0.1.1\t$new_hostname" /etc/hosts
    else
        echo -e "127.0.1.1\t$new_hostname" >> /etc/hosts
    fi
    
    # 显示修改后的主机名信息
    echo ""
    echo "✅ 主机名修改成功！当前主机名信息："
    hostnamectl status
    
    echo ""
    echo "🎉 主机名设置完成！建议重启一次系统以确保所有服务生效（推荐）。"
}

function install_qemu_agent(){
    # 2.13 安装qemu-guest-agent
    #!/bin/bash
    
    echo "🚩 Debian 12 (PVE 虚拟机) qemu-guest-agent 自动安装脚本"
    
    # 检查是否以 root 权限运行
    if [ "$EUID" -ne 0 ]; then
        echo "❌ 请以 root 或 sudo 权限运行此脚本！"
        exit 1
    fi
    
    # 检查是否已安装 qemu-guest-agent
    if dpkg -s qemu-guest-agent &> /dev/null; then
        echo "✅ qemu-guest-agent 已安装，跳过安装步骤。"
    else
        # 更新软件源并安装 qemu-guest-agent
        echo "✅ 正在更新软件源并安装 qemu-guest-agent..."
        apt update
        apt install -y qemu-guest-agent
    fi
    
    # 启用并启动 qemu-guest-agent 服务
    echo "✅ 正在启用并启动 qemu-guest-agent 服务..."
    systemctl enable --now qemu-guest-agent
    
    # 检查服务运行状态
    echo ""
    if systemctl is-active qemu-guest-agent | grep -q "active"; then
        echo "✅ qemu-guest-agent 服务已成功运行！"
    else
        echo "❌ qemu-guest-agent 服务启动失败，请手动检查！"
        exit 1
    fi
    
    echo ""
    echo "🎉 qemu-guest-agent 安装和配置完成！"
    echo "🔄 请重启此虚拟机，以确保 Proxmox VE 能完整识别并使用 qemu-guest-agent！"
}

function install_openssh(){
    # 2.14 安装openssh
    #!/bin/bash
    echo "🚀 正在安装OpenSSH服务并启用root登录..."
    apt update && apt install -y openssh-server
    systemctl enable --now ssh
    
    SSH_CONFIG="/etc/ssh/sshd_config"
    BACKUP_CONFIG="/etc/ssh/sshd_config.bak_$(date '+%Y%m%d_%H%M%S')"
    cp ${SSH_CONFIG} ${BACKUP_CONFIG}
    
    sed -i 's/^#*PermitRootLogin.*/PermitRootLogin yes/' ${SSH_CONFIG}
    sed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication yes/' ${SSH_CONFIG}
    
    systemctl restart ssh
}

function monitor_system(){
    # 2.15 监控系统运行状态
    #!/bin/bash
    
    # 定义Ctrl+C退出时的提示函数
    exit_script() {
        echo ""
        echo "👋 已退出系统实时状态监控。"
        exit 0
    }
    
    # 捕获Ctrl+C信号，调用退出函数
    trap exit_script SIGINT
    
    # 无限循环展示系统状态，每2秒刷新一次
    while true
    do
        clear
        echo "📊 Debian 12 系统实时状态监控（每2秒刷新）"
        echo "==================================================="
        
        # 当前系统时间
        echo -e "\n⏰ 当前系统时间：$(date '+%Y-%m-%d %H:%M:%S')"
        
        # 主机名和系统版本信息
        echo -e "\n🔖 主机名：$(hostname)"
        echo "📌 系统版本：$(lsb_release -d | awk -F '\t' '{print $2}')"
        
        # 系统运行时间
        echo -e "\n🚀 系统运行时间：$(uptime -p)"
        
        # CPU使用率与负载
        echo -e "\n🖥️ CPU使用率与负载："
        top -b -n1 | grep "Cpu(s)" | awk '{print "当前CPU使用情况： " 100 - $8 "%"}'
        echo "负载情况：" $(uptime | awk '{print $(NF-2), $(NF-1), $(NF)}')
        
        # 内存使用情况
        echo -e "\n📚 内存使用情况："
        free -h | awk '/^Mem:/ {print "总内存: "$2 ", 已使用: "$3 ", 空闲: "$4 ", 可用: "$7}'
        
        # 磁盘使用情况
        echo -e "\n💾 磁盘空间使用情况："
        df -hT -x tmpfs -x devtmpfs | awk 'NR==1 || /^\/dev\// {print $0}'
        
        # 网络IP地址
        echo -e "\n🌐 网络IP地址："
        hostname -I | awk '{print $1}' | xargs -I{} echo "本机IP地址: {}"
        
        # Docker容器状态 (新增功能！)
        echo -e "\n🐳 Docker容器运行状态："
        if command -v docker &> /dev/null; then
            docker_ps=$(docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}")
            
            if [[ $(docker ps -q | wc -l) -gt 0 ]]; then
                echo "当前运行的容器："
                echo "$docker_ps"
            else
                echo "⚠️ 当前没有运行中的Docker容器。"
            fi
        else
            echo "❌ 未检测到Docker环境，请先安装Docker。"
        fi
        
        echo -e "\n==================================================="
        echo "✨ 按 Ctrl + C 随时退出监控。"
        
        # 等待2秒后刷新
        sleep 2
    done
}

# 脚本主循环，执行完一个功能后返回菜单
while true; do
    main_menu
    read -p "🚩 按回车键返回主菜单..." temp
done
```

- 增加执行权限

```bash
chmod +x auto-script.sh
```

- 运行

```bash 
./auto-script.sh
```

##  二、脚本内容讲解

### 2.1 配置静态ip

```bash
#!/bin/bash

# Debian 12 静态IP配置脚本，直接编辑 /etc/network/interfaces，并手动更新 /etc/resolv.conf DNS设置

INTERFACES_FILE="/etc/network/interfaces"
RESOLV_FILE="/etc/resolv.conf"

# 备份当前配置
cp ${INTERFACES_FILE} ${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
cp ${RESOLV_FILE} ${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
echo "已备份网络配置文件：${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
echo "已备份DNS配置文件：${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"

# 输入网卡名称
read -p "请输入网卡名（如eth0或ens18，默认ens18）: " INTERFACE
INTERFACE=${INTERFACE:-ens18}

# 获取系统当前IP、掩码、网关、DNS作为默认值
CURRENT_IP=$(ip -4 addr show ${INTERFACE} | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
CURRENT_NETMASK=$(ifconfig ${INTERFACE} | grep -oP '(?<=netmask\s)\d+(\.\d+){3}')
CURRENT_GATEWAY=$(ip route | grep default | grep ${INTERFACE} | awk '{print $3}')
CURRENT_DNS=$(grep "nameserver" /etc/resolv.conf | head -n1 | awk '{print $2}')

# 设置默认值（如果获取不到则使用常规默认值）
[ -z "$CURRENT_NETMASK" ] && CURRENT_NETMASK="255.255.255.0"
[ -z "$CURRENT_GATEWAY" ] && CURRENT_GATEWAY="192.168.1.1"
[ -z "$CURRENT_DNS" ] && CURRENT_DNS="8.8.8.8"

# 用户输入新配置，提供默认值
read -p "请输入静态IP地址（默认：${CURRENT_IP}）: " STATIC_IP
STATIC_IP=${STATIC_IP:-$CURRENT_IP}

read -p "请输入子网掩码（默认：${CURRENT_NETMASK}）: " NETMASK
NETMASK=${NETMASK:-$CURRENT_NETMASK}

read -p "请输入网关地址（默认：${CURRENT_GATEWAY}）: " GATEWAY
GATEWAY=${GATEWAY:-$CURRENT_GATEWAY}

read -p "请输入DNS服务器（默认：${CURRENT_DNS}，多个DNS空格分隔）: " DNS
DNS=${DNS:-$CURRENT_DNS}

# 删除 interfaces 文件中已有的该网卡配置（若存在）
sed -i "/iface ${INTERFACE} inet/,/^$/d" ${INTERFACES_FILE}
sed -i "/auto ${INTERFACE}/d" ${INTERFACES_FILE}
sed -i "/allow-hotplug ${INTERFACE}/d" ${INTERFACES_FILE}

# 写入新的静态IP配置到interfaces文件
cat >> ${INTERFACES_FILE} <<EOF

auto ${INTERFACE}
iface ${INTERFACE} inet static
    address ${STATIC_IP}
    netmask ${NETMASK}
    gateway ${GATEWAY}
EOF

echo "静态IP地址已成功配置到${INTERFACES_FILE}"

# 写入DNS配置到resolv.conf文件
echo "# Generated by setup_static_ip.sh on $(date)" > ${RESOLV_FILE}
for dns_server in ${DNS}
do
    echo "nameserver ${dns_server}" >> ${RESOLV_FILE}
done

echo "DNS已成功配置到${RESOLV_FILE}"

# 重启网络服务以应用配置
systemctl restart networking

# 显示当前网络配置与DNS配置
echo "当前${INTERFACE}接口网络信息为："
ip addr show ${INTERFACE}
echo ""
echo "当前DNS配置信息为："
cat ${RESOLV_FILE}
```

### 2.2 恢复dhcp

```bash
#!/bin/bash

# Debian 12 恢复 DHCP 配置脚本
# 直接编辑 /etc/network/interfaces 文件并恢复DNS为DHCP自动获取

INTERFACES_FILE="/etc/network/interfaces"
RESOLV_FILE="/etc/resolv.conf"

# 备份当前配置
cp ${INTERFACES_FILE} ${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
cp ${RESOLV_FILE} ${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
echo "已备份网络配置文件：${INTERFACES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"
echo "已备份DNS配置文件：${RESOLV_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"

# 输入网卡名称
read -p "请输入要恢复 DHCP 的网卡名（默认 ens18）: " INTERFACE
INTERFACE=${INTERFACE:-ens18}

# 删除 interfaces 文件中已有的该网卡配置（若存在）
sed -i "/iface ${INTERFACE} inet/,/^$/d" ${INTERFACES_FILE}
sed -i "/auto ${INTERFACE}/d" ${INTERFACES_FILE}
sed -i "/allow-hotplug ${INTERFACE}/d" ${INTERFACES_FILE}

# 写入 DHCP 配置到 interfaces 文件
cat >> ${INTERFACES_FILE} <<EOF

allow-hotplug ${INTERFACE}
iface ${INTERFACE} inet dhcp
EOF

echo "已成功恢复 DHCP 配置到 ${INTERFACES_FILE}"

# 清空 resolv.conf 以便 DHCP 自动更新DNS
echo "# Generated by restore_dhcp.sh on $(date)" > ${RESOLV_FILE}

# 重启网络服务应用配置
systemctl restart networking

# 等待几秒钟让 DHCP 获取地址
echo "请稍等几秒钟，让 DHCP 获取 IP 地址..."
sleep 5

# 显示当前网络配置和DNS配置
echo "当前 ${INTERFACE} 接口网络信息为："
ip addr show ${INTERFACE}
echo ""
echo "当前 DNS 配置信息为："
cat ${RESOLV_FILE}
```

### 2.3 换中科大源

```bash
#!/bin/bash

# Debian 12 一键换源脚本（中国科学技术大学源）
SOURCES_FILE="/etc/apt/sources.list"

# 备份原sources.list文件
cp ${SOURCES_FILE} ${SOURCES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')
echo "已备份原文件为 ${SOURCES_FILE}.bak_$(date '+%Y%m%d_%H%M%S')"

# 清空原文件内容，并写入新源内容
cat > ${SOURCES_FILE} <<EOF
# 默认注释了源码仓库，如有需要可自行取消注释
deb http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware
# deb-src http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware
deb http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware
# deb-src http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware

# backports 软件源，请按需启用
# deb http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware
# deb-src http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware
EOF

echo "已成功替换软件源为中国科学技术大学镜像源。"

# 更新软件源
apt update
```

### 2.4 安装ufw

```bash
#!/bin/bash

# Debian 12 检查并安装UFW防火墙脚本

# 检查是否已安装UFW
if dpkg -s ufw &> /dev/null; then
    echo "✅ UFW 已经安装，无需再次安装。"
else
    echo "⚙️ UFW 未安装，正在安装中..."
    apt update
    apt install -y ufw

    # 再次检查是否成功安装
    if dpkg -s ufw &> /dev/null; then
        echo "✅ UFW 安装成功！"
    else
        echo "❌ UFW 安装失败，请检查网络或软件源设置！"
        exit 1
    fi
fi

# 显示UFW当前状态
echo ""
echo "🔍 当前UFW状态："
ufw status verbose
```

### 2.5 ufw配置防火墙

```bash
#!/bin/bash

# Debian 12 UFW 防火墙配置脚本（用户自定义允许或禁用端口）

# 检查UFW是否已安装
if ! dpkg -s ufw &> /dev/null; then
    echo "⚠️ UFW 尚未安装，请先执行安装脚本再进行此操作。"
    exit 1
fi

echo "🚀 开始配置UFW防火墙..."

# 设置默认规则
echo "⚙️ 设置默认规则：默认拒绝入站流量，允许出站流量..."
ufw default deny incoming
ufw default allow outgoing

# 显示当前ufw状态
echo ""
echo "📋 当前UFW规则如下:"
ufw status numbered
echo ""

# 允许用户新增端口
read -p "🛡️ 是否需要允许新的端口？(y/n): " open_ports
if [[ "$open_ports" =~ ^[Yy]$ ]]; then
    read -p "请输入你想允许的端口号(如22 80 443)，多个端口以空格分隔: " ports_allow
    for port in $ports_allow; do
        ufw allow $port && echo "✅ 已允许端口 $port"
    done
fi

# 允许用户禁用之前开放的端口
read -p "🚫 是否需要禁用之前开放的端口？(y/n): " close_ports
if [[ "$close_ports" =~ ^[Yy]$ ]]; then
    read -p "请输入你想禁用的端口号(如22 80 443)，多个端口以空格分隔: " ports_deny
    for port in $ports_deny; do
        ufw delete allow $port && echo "✅ 已禁用端口 $port" || echo "⚠️ 禁用端口 $port 时出错或不存在该规则"
    done
fi

# 启用ufw（如果未启用）
echo ""
echo "🟢 启用UFW防火墙..."
ufw --force enable

# 重载规则
ufw reload

# 显示当前防火墙状态
echo ""
echo "📋 最终UFW防火墙状态:"
ufw status verbose
```

### 2.6 安装docker和docker compose

```bash
apt update
apt install ca-certificates curl
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
chmod a+r /etc/apt/keyrings/docker.asc

echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.aliyun.com/docker-ce/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" |tee /etc/apt/sources.list.d/docker.list > /dev/null

apt update
apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y

systemctl start docker
systemctl enable docker

docker --version
docker compose version
```

### 2.7 ssh免密登陆设置

```bash
#!/bin/bash

# SSH免密登录配置脚本（客户端Windows）

echo "🚀 本脚本帮助你设置SSH公钥登录（免密码登录）"
echo ""

# 提示用户在本地生成密钥对
echo "🔑 请在你的 Windows 10 客户端执行下面命令生成密钥对（如未生成）："
echo ""
echo "    ssh-keygen -t rsa -b 4096"
echo ""
echo "⚠️ 命令执行后一路回车即可，密钥默认保存在 C:\\Users\\你的用户名\\.ssh\\"
echo ""

# 提示用户打开公钥文件并复制内容
echo "📋 请在 Windows 上打开公钥文件（默认路径）："
echo ""
echo "    C:\\Users\\你的用户名\\.ssh\\id_rsa.pub"
echo ""
echo "然后复制里面所有内容，接下来将在服务器端粘贴。"
echo ""

# 等待用户确认
read -p "✅ 已复制公钥内容到剪贴板了吗？（y/n）：" is_copied

if [[ "$is_copied" =~ ^[Yy]$ ]]; then
    # 创建.ssh目录并设置权限
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh

    # 用户粘贴公钥到authorized_keys
    echo ""
    echo "✏️ 请将刚才复制的SSH公钥内容粘贴到下方："
    read -r ssh_pubkey

    # 检查是否为空
    if [[ -z "$ssh_pubkey" ]]; then
        echo "⚠️ 错误：未检测到公钥内容，退出配置。"
        exit 1
    fi

    # 将公钥写入authorized_keys文件
    echo "$ssh_pubkey" >> ~/.ssh/authorized_keys
    chmod 600 ~/.ssh/authorized_keys

    echo ""
    echo "✅ 公钥添加成功！"
else
    echo "⚠️ 请先完成公钥复制操作，再重新运行本脚本。"
    exit 1
fi

# 提示用户测试免密登陆
server_ip=$(hostname -I | awk '{print $1}')
current_user=$(whoami)

echo ""
echo "🚩 现在请在 Windows 客户端上测试SSH免密登陆，命令如下："
echo ""
echo "    ssh ${current_user}@${server_ip}"
echo ""

echo "如果一切顺利，你无需输入密码即可成功登陆！🚀"
```

### 2.8 系统垃圾清理

```bash
#!/bin/bash

# 自动创建 Debian 垃圾清理脚本并配置每月末自动执行的任务

CLEANUP_SCRIPT="/usr/local/bin/system_cleanup.sh"
LOG_FILE="/var/log/system_cleanup.log"

echo "🚩开始创建系统垃圾清理脚本..."

# 创建自动清理脚本
cat > ${CLEANUP_SCRIPT} <<'EOF'
#!/bin/bash

# Debian 系统垃圾自动清理脚本

# 清理APT缓存
apt clean
apt autoclean
apt autoremove -y

# 删除临时文件
rm -rf /tmp/* /var/tmp/*

# 删除旧的压缩日志
find /var/log -type f -name "*.gz" -exec rm -f {} \;
find /var/log -type f -name "*.1" -exec rm -f {} \;

# 清空其他日志文件
find /var/log -type f -exec truncate -s 0 {} \;

# 删除用户的缩略图缓存（如果有图形界面）
rm -rf /home/*/.cache/thumbnails/*

# 输出执行时间到日志
echo "系统垃圾清理完成于 $(date)" >> /var/log/system_cleanup.log
EOF

# 给脚本赋予执行权限
chmod +x ${CLEANUP_SCRIPT}

echo "✅ 垃圾清理脚本创建成功，路径为：${CLEANUP_SCRIPT}"

# 配置定时任务（每月月底自动执行）
echo "🚩 正在配置定时任务..."

(crontab -l 2>/dev/null | grep -v "${CLEANUP_SCRIPT}"; \
echo '59 23 28-31 * * [ "$(date -d tomorrow '\''+\%d'\'')" = "01" ] && /usr/local/bin/system_cleanup.sh') | crontab -

echo "✅ 定时任务配置完成！"

# 检查任务是否添加成功
echo ""
echo "🚩 正在检查定时任务是否添加成功..."

if crontab -l | grep -q "${CLEANUP_SCRIPT}"; then
    echo "✅ 定时任务添加成功！当前定时任务列表如下："
    crontab -l | grep "${CLEANUP_SCRIPT}"
else
    echo "❌ 定时任务添加失败，请检查后重试！"
    exit 1
fi

echo ""
echo "🎉全部配置完成！系统每月最后一天23:59将自动清理垃圾文件。"
echo "清理日志在：${LOG_FILE}"
```

### 2.9 系统性能和存储优化

```bash
#!/bin/bash

echo "🚀 开始 Debian 12 (PVE 虚拟机) 性能优化..."

# 1️⃣ 优化 swappiness 参数为10，降低swap使用频率
echo "✅ 正在设置 swappiness 参数为10..."
if grep -q "vm.swappiness" /etc/sysctl.conf; then
    sed -i 's/^vm.swappiness.*/vm.swappiness = 10/' /etc/sysctl.conf
else
    echo "vm.swappiness = 10" >> /etc/sysctl.conf
fi
sysctl -p

# 2️⃣ 启用 TCP BBR 拥塞控制算法以提高网络性能（虚拟机适用）
echo "✅ 正在启用 TCP BBR 拥塞控制算法..."
if ! grep -q "net.core.default_qdisc" /etc/sysctl.conf; then
    echo "net.core.default_qdisc = fq" >> /etc/sysctl.conf
fi
if ! grep -q "net.ipv4.tcp_congestion_control" /etc/sysctl.conf; then
    echo "net.ipv4.tcp_congestion_control = bbr" >> /etc/sysctl.conf
fi
sysctl -p

# 验证 TCP BBR 是否启用成功
if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
    echo "✅ TCP BBR 已成功启用！"
else
    echo "❌ TCP BBR 启用失败，请检查内核版本是否支持！"
fi

# 3️⃣ 检测虚拟机磁盘是否支持 TRIM (discard)，再决定是否启用定期 TRIM
echo "✅ 正在检测虚拟磁盘是否支持 TRIM (discard)..."

DISCARD_SUPPORT=$(lsblk -D | awk 'NR>1 && $4=="0B" {print $1}' | wc -l)

if [ "$DISCARD_SUPPORT" -ne 0 ]; then
    echo "⚠️ 检测到虚拟磁盘不支持 TRIM，跳过启用 fstrim 服务。"
else
    echo "✅ 虚拟磁盘支持 TRIM，正在启用 fstrim 服务..."
    systemctl enable --now fstrim.timer

    # 验证 fstrim 服务状态
    if systemctl is-enabled fstrim.timer | grep -q "enabled"; then
        echo "✅ fstrim 定期 TRIM 服务已成功启用！"
    else
        echo "❌ fstrim 服务启用失败，请手动检查。"
    fi
fi

echo ""
echo "🎉 Debian 12 (PVE 虚拟机) 性能优化配置完成！"
```

### 2.10 时间同步和设置时区

```bash
#!/bin/bash

echo "🌐 Debian 12 (PVE虚拟机) 时间同步与时区设置脚本【默认时区: Asia/Shanghai】"

# 检查是否以root权限运行
if [ "$EUID" -ne 0 ]; then
    echo "❌ 请以 root 或 sudo 权限运行此脚本！"
    exit 1
fi

# 第一步：安装和启用chrony服务进行时间同步
echo "🚩 正在安装和启用chrony时间同步服务..."
apt update
apt install -y chrony

# 启用并启动chrony服务
systemctl enable --now chrony

# 验证chrony服务是否启动成功
if systemctl is-active chrony | grep -q "active"; then
    echo "✅ chrony服务已成功启动和启用！"
else
    echo "❌ chrony服务启动失败，请手动检查！"
    exit 1
fi

# 强制进行一次时间同步
chronyc -a makestep

# 显示当前时间同步源状态
echo ""
echo "🕒 当前chrony时间同步源状态："
chronyc sources -v
echo ""

# 第二步：交互式设置时区（默认Asia/Shanghai，按回车使用默认值）
default_timezone="Asia/Shanghai"
current_tz=$(timedatectl | grep "Time zone" | awk '{print $3}')
echo "⏰ 当前系统时区为：$current_tz"
echo ""

echo "请输入你想设置的时区，例如：Asia/Shanghai"
echo "可用的时区列表参考：https://en.wikipedia.org/wiki/List_of_tz_database_time_zones"
read -p "请输入新的时区 (默认: ${default_timezone}): " new_timezone

# 如果用户未输入，使用默认值
if [ -z "$new_timezone" ]; then
    new_timezone="$default_timezone"
fi

# 检查用户输入的时区是否有效
if [ ! -f "/usr/share/zoneinfo/$new_timezone" ]; then
    echo "❌ 时区 [$new_timezone] 不存在，请检查拼写后重新运行脚本！"
    exit 1
fi

# 设置新时区
timedatectl set-timezone "$new_timezone"

# 显示设置后的时区和时间
echo ""
echo "✅ 时区设置成功！当前时区为：$(timedatectl | grep "Time zone" | awk '{print $3}')"
echo "🕒 当前系统时间为：$(date)"
```

### 2.11 禁用ipv6

```bash
#!/bin/bash

echo "🚩 开始禁用 Debian 12 系统 IPv6 功能..."

# 检查是否以root权限运行
if [ "$EUID" -ne 0 ]; then
    echo "❌ 请以 root 或 sudo 权限运行此脚本！"
    exit 1
fi

# 备份sysctl.conf文件
sysctl_conf="/etc/sysctl.conf"
backup_conf="/etc/sysctl.conf.bak_ipv6"
if [ ! -f "$backup_conf" ]; then
    cp $sysctl_conf $backup_conf
    echo "✅ 已备份原始sysctl.conf至 $backup_conf"
fi

# 禁用IPv6的sysctl配置
echo "✅ 正在配置禁用IPv6..."
cat <<EOF >> $sysctl_conf

# 禁用IPv6
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1
EOF

# 立即应用配置
sysctl -p

# 禁用IPv6模块加载（可选，推荐）
echo "✅ 正在配置禁止IPv6模块加载..."
modprobe_conf="/etc/modprobe.d/disable_ipv6.conf"
echo "options ipv6 disable=1" > $modprobe_conf

# 更新initramfs使模块禁用生效
update-initramfs -u

# 验证IPv6是否禁用成功
if sysctl net.ipv6.conf.all.disable_ipv6 | grep -q "1"; then
    echo "✅ IPv6已成功禁用！"
else
    echo "❌ IPv6禁用失败，请手动检查！"
fi

echo ""
echo "🎉 Debian 12 IPv6禁用配置完成！请重启系统以确保彻底生效（推荐）！"
```

### 2.12 修改主机名

```bash
#!/bin/bash

echo "🚩 Debian 12 主机名修改脚本"

# 检查是否以root权限运行
if [ "$EUID" -ne 0 ]; then
    echo "❌ 请以 root 或 sudo 权限运行此脚本！"
    exit 1
fi

# 显示当前主机名
current_hostname=$(hostnamectl hostname)
echo "🔖 当前主机名为：$current_hostname"
echo ""

# 提示用户输入新的主机名 (默认为当前主机名)
read -p "请输入新的主机名 (默认: $current_hostname): " new_hostname

# 如果用户没有输入，使用当前主机名
if [ -z "$new_hostname" ]; then
    new_hostname=$current_hostname
fi

# 验证主机名合法性（仅允许字母、数字、短横线，长度1-63字符）
if [[ ! $new_hostname =~ ^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}$ ]]; then
    echo "❌ 主机名 [$new_hostname] 不合法！仅允许字母、数字、短横线，且长度为1-63字符。"
    exit 1
fi

# 设置新主机名
echo "✅ 正在设置新主机名为：$new_hostname"
hostnamectl set-hostname "$new_hostname"

# 修改/etc/hosts文件，确保主机名解析正确
if grep -q "127.0.1.1" /etc/hosts; then
    sed -i "/127.0.1.1/c\127.0.1.1\t$new_hostname" /etc/hosts
else
    echo -e "127.0.1.1\t$new_hostname" >> /etc/hosts
fi

# 显示修改后的主机名信息
echo ""
echo "✅ 主机名修改成功！当前主机名信息："
hostnamectl status

echo ""
echo "🎉 主机名设置完成！建议重启一次系统以确保所有服务生效（推荐）。"
```

### 2.13 安装qemu-guest-agent

```bash
#!/bin/bash

echo "🚩 Debian 12 (PVE 虚拟机) qemu-guest-agent 自动安装脚本"

# 检查是否以 root 权限运行
if [ "$EUID" -ne 0 ]; then
    echo "❌ 请以 root 或 sudo 权限运行此脚本！"
    exit 1
fi

# 检查是否已安装 qemu-guest-agent
if dpkg -s qemu-guest-agent &> /dev/null; then
    echo "✅ qemu-guest-agent 已安装，跳过安装步骤。"
else
    # 更新软件源并安装 qemu-guest-agent
    echo "✅ 正在更新软件源并安装 qemu-guest-agent..."
    apt update
    apt install -y qemu-guest-agent
fi

# 启用并启动 qemu-guest-agent 服务
echo "✅ 正在启用并启动 qemu-guest-agent 服务..."
systemctl enable --now qemu-guest-agent

# 检查服务运行状态
echo ""
if systemctl is-active qemu-guest-agent | grep -q "active"; then
    echo "✅ qemu-guest-agent 服务已成功运行！"
else
    echo "❌ qemu-guest-agent 服务启动失败，请手动检查！"
    exit 1
fi

echo ""
echo "🎉 qemu-guest-agent 安装和配置完成！"
echo "🔄 请重启此虚拟机，以确保 Proxmox VE 能完整识别并使用 qemu-guest-agent！"
```

### 2.14 安装openssh

```bash
#!/bin/bash
echo "🚀 正在安装OpenSSH服务并启用root登录..."
apt update && apt install -y openssh-server
systemctl enable --now ssh

SSH_CONFIG="/etc/ssh/sshd_config"
BACKUP_CONFIG="/etc/ssh/sshd_config.bak_$(date '+%Y%m%d_%H%M%S')"
cp ${SSH_CONFIG} ${BACKUP_CONFIG}

sed -i 's/^#*PermitRootLogin.*/PermitRootLogin yes/' ${SSH_CONFIG}
sed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication yes/' ${SSH_CONFIG}

systemctl restart ssh
```

### 2.15 监控系统运行状态

```bash
#!/bin/bash

# 定义Ctrl+C退出时的提示函数
exit_script() {
    echo ""
    echo "👋 已退出系统实时状态监控。"
    exit 0
}

# 捕获Ctrl+C信号，调用退出函数
trap exit_script SIGINT

# 无限循环展示系统状态，每2秒刷新一次
while true
do
    clear
    echo "📊 Debian 12 系统实时状态监控（每2秒刷新）"
    echo "==================================================="

    # 当前系统时间
    echo -e "\n⏰ 当前系统时间：$(date '+%Y-%m-%d %H:%M:%S')"

    # 主机名和系统版本信息
    echo -e "\n🔖 主机名：$(hostname)"
    echo "📌 系统版本：$(lsb_release -d | awk -F '\t' '{print $2}')"

    # 系统运行时间
    echo -e "\n🚀 系统运行时间：$(uptime -p)"

    # CPU使用率与负载
    echo -e "\n🖥️ CPU使用率与负载："
    top -b -n1 | grep "Cpu(s)" | awk '{print "当前CPU使用情况： " 100 - $8 "%"}'
    echo "负载情况：" $(uptime | awk '{print $(NF-2), $(NF-1), $(NF)}')

    # 内存使用情况
    echo -e "\n📚 内存使用情况："
    free -h | awk '/^Mem:/ {print "总内存: "$2 ", 已使用: "$3 ", 空闲: "$4 ", 可用: "$7}'

    # 磁盘使用情况
    echo -e "\n💾 磁盘空间使用情况："
    df -hT -x tmpfs -x devtmpfs | awk 'NR==1 || /^\/dev\// {print $0}'

    # 网络IP地址
    echo -e "\n🌐 网络IP地址："
    hostname -I | awk '{print $1}' | xargs -I{} echo "本机IP地址: {}"

    # Docker容器状态 (新增功能！)
    echo -e "\n🐳 Docker容器运行状态："
    if command -v docker &> /dev/null; then
        docker_ps=$(docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}")

        if [[ $(docker ps -q | wc -l) -gt 0 ]]; then
            echo "当前运行的容器："
            echo "$docker_ps"
        else
            echo "⚠️ 当前没有运行中的Docker容器。"
        fi
    else
        echo "❌ 未检测到Docker环境，请先安装Docker。"
    fi

    echo -e "\n==================================================="
    echo "✨ 按 Ctrl + C 随时退出监控。"

    # 等待2秒后刷新
    sleep 2
done
```

